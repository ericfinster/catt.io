coh id {C : Cat} (x :: C)
  : x => x

coh comp {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
  : x => z

coh comp2 {C2 : Cat}
    {x2 :: C2}
    {y2 :: C2} (f2 :: x2 => y2)
    {z2 :: C2} (g2 :: y2 => z2)
  : x2 => z2

coh comp3 {C3 : Cat}
    {x3 :: C3}
    {y3 :: C3} (f3 :: x3 => y3)
    {z3 :: C3} (g3 :: y3 => z3)
  : x3 => z3

let reduce-assoc {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
    {w :: C} (h :: z => w) : [ x => w ] = comp f (comp2 g h)

let reduce-assoc-2 {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
    {w :: C} (h :: z => w) : [ x => w ] = comp (comp2 f g) h

let reduce-assoc-3 {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
    {w :: C} (h :: z => w)
    {v :: C} (i :: w => v) : [ x => v ] = comp (comp2 f g) (comp3 h i)

coh horiz C (x(f(a)g)y(h(b)i)z) : comp f h => comp g i
coh horiz2 C (x2(f2(a2)g2)y2(h2(b2)i2)z2) : comp2 f2 h2 => comp2 g2 i2

let this-should-reduce {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
    {w :: C} (h :: z => w)
    : [ x => w ] = comp f ((coh [ C2 (x2(f2)y2(g2)z2) : C2 |> x2 => z2]) g h)

let reduce-test {C : Cat}
  {x :: C}
  {y :: C} {f :: x => y}
     	   {f2 :: x => y} (a :: f => f2)
  {z :: C} {g :: y => z}
     	   {g2 :: y => z} (b :: g => g2)
  {w :: C} {h :: z => w}
     	   {h2 :: z => w} (c :: h => h2) : [ comp f (comp2 g h) => comp f2 (comp2 g2 h2) ]
   = horiz a (horiz2 b c)

let test {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y) : [ x => y ] = comp f (id y)

coh unitor C (x(f)y) : comp f (id y) => f
coh comp-v C (x(f(a)g(b)h)y) : f => h

let test2 {C : Cat}
  {x :: C}
  {y :: C} { f :: x => y }
     	   { g :: x => y } (a :: f => g) : [ f => g ]
	   = comp-v a (unitor g)

# coh fake-id C (x(f)y(g)z) : comp f g => comp f g

# let endo-coherence {C : Cat}
#     {x :: C}
#     {y :: C} (f :: x => y)
#     {z :: C} (g :: y => z) : [ comp f g => comp f g ] = fake-id f g

coh idv C (x(f)y) : f => f

let test2d {C : Cat}
    {x :: C}
    {y :: C} {f :: x => y}
       	     {g :: x => y} (a :: f => g) : [ f => g ] = comp-v a (idv g)
