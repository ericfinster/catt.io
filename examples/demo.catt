#
#  demo.catt - new syntax demo and whatnot
#

coh id {C : Cat} (x :: C)
  : x => x

# coh id_fail C (x(f)y) : x => x

coh comp {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
  : x => z
  
coh assoc {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
    {w :: C} (h :: z => w)
  : comp f (comp g h) =>
    comp (comp f g) h

# coh assoc_fail C (x(f)y(g)z(h)w(k)s)
#   : comp f (comp g h) =>
#     comp (comp f g) h
  
coh unit_l {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
  : comp (id x) f => f

coh unit_r {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
  : comp f (id y) => f

coh horiz {C : Cat}
    {x :: C}
    {y :: C} {f :: x => y}
             {g :: x => y} (a :: f => g)
    {z :: C} {h :: y => z}
       	     {k :: y => z} (b :: h => k)
  : comp f h => comp g k 

coh vert {C : Cat}
    {x :: C}
    {y :: C} {f :: x => y}
       	     {g :: x => y} (a :: f => g)
	     {h :: x => y} (b :: g => h)
  : f => h

# this shows that unification can automatically
# detect suspensions!
let vert_alt {C : Cat}
    {x :: C}
    {y :: C} {f :: x => y}
       	     {g :: x => y} (a :: f => g)
	     {h :: x => y} (b :: g => h)
  : [ f => h ]
  = comp a b

let twice {C : Cat} {x :: C} (f :: x => x) : [ x => x ]
    = comp f f

let precomp {C : Cat} {x :: C} {y :: C} {z :: C} (f :: x => y)
  : [ y => z ] -> [ x => z ]
  = comp f 

let postcomp {C : Cat} {x :: C} {y :: C} {z :: C} (g :: y => z)
  : [ x => y ] -> [ x => z ]
  = \f. comp f g
  
#
#  Unbiased composites
#

let comp_un_pd {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
  : [ x => z ]
  = ucomp [ (()()) ] f g

let comp_un_seq {C : Cat}
    {x :: C}
    {y :: C} (f :: x => y)
    {z :: C} (g :: y => z)
  : [ x => z ]
  = ucomp [ 1 0 1 ] f g

#
#  Abbreviated pd syntax
#

coh id_abr C (x) : x => x
coh comp_abr C (x(f)y(g)z) : x => z

coh assoc_abr C (x(f)y(g)z(h)w)
  : comp_abr f (comp_abr g h) =>
    comp_abr (comp_abr f g) h

coh ichg C (x(f(a)g(b)h)y(i(c)j(d)k)z)
  : ucomp [ 2 0 2 ] (ucomp [ 2 1 2 ] a b) (ucomp [ 2 1 2 ] c d) =>
    ucomp [ 2 1 2 ] (ucomp [ 2 0 2 ] a c) (ucomp [ 2 0 2 ] b d)
